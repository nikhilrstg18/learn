{"componentChunkName":"component---src-templates-book-js","path":"/books/dotnet/","result":{"data":{"markdownRemark":{"html":"<h2>.Net Framework Vs .Net Standard Vs .Net</h2>\n<ul>\n<li><code class=\"language-text\">.NET Framework</code> is the original implementation of .NET. It supports running websites, services, desktop apps, and more on Windows</li>\n<li><code class=\"language-text\">.NET Standard</code> is a formal specification of the APIs that are common across .NET implementations. This allows the same code and libraries to run on different implementations.</li>\n<li><code class=\"language-text\">.NET</code> is a cross-platform implementation for running websites, services, and console apps on Windows, Linux, and macOS. .NET is open source on GitHub. .NET was previously called <code class=\"language-text\">.NET Core</code></li>\n</ul>\n<h2>C# vs .Net</h2>\n<p><code class=\"language-text\">C#</code> is <em>programming language</em></p>\n<p><code class=\"language-text\">.NET</code> is free, open-source, secure, reliable, and high-performance <code class=\"language-text\">application platform</code>.</p>\n<h2>Architecture of .Net Framework</h2>\n<p><img src=\"https://dotnet.microsoft.com/static/images/illustrations/swimlane-architecture-framework.svg\" alt=\".net arch\"></p>\n<p>2 major components are</p>\n<ol>\n<li>The <strong>Common Language Runtime (CLR)</strong> is the execution engine that handles running applications. It provides services like thread management, garbage collection, type-safety, exception handling, and more</li>\n<li>The <strong>Class Library</strong> provides a set of APIs and types for common functionality. It provides types for strings, dates, numbers, etc. The Class Library includes APIs for reading and writing files, connecting to databases, drawing, and more</li>\n</ol>\n<p>.NET applications are written in the C#, F#, or Visual Basic programming language. Code is compiled into a language-agnostic Common Intermediate Language (CIL). Compiled code is stored in assemblies—files with a .dll or .exe file extension.</p>\n<p>When an app runs, the CLR takes the assembly and uses a just-in-time compiler (JIT) to turn it into machine code that can execute on the specific architecture of the computer it is running on.</p>\n<h2>CLR (Common Language Runtime)</h2>\n<p>Before we understand CLR and what it is, we need to under a little history of C#</p>\n<p><code class=\"language-text\">History - Problem</code></p>\n<p>Before C#, we have 2 popular languages C/ C++. With either of these languages when we compile our app, the compiler translates our code into native code for the machine it was running.</p>\n<p>Which means if I run an app in C++ on a windows machine with 8086 CPU architecture, the compiler would translate that code into native code for that machine (i.e. window machine with 8086 architecture).</p>\n<p>In market, we have different H/W and OS, So if we compile an app on 1 set of H/W or OS, that compiled code would not run on different set of H/W or OS. Which gave the need to make it platform independent</p>\n<p><code class=\"language-text\">Solution</code></p>\n<p>So, When Microsoftwas designing C#, they borrowred the idea of JVM from Java community. In Java, when code is compiled, its not directly translated to native code, its first translated into intermediate language called bytecode</p>\n<p>And we have the exact same concept in C#, So when you compile c# code, the result is IL code which is independent of the machine on which it is running.Now we need something that should take the compiled IL code and translates to Native Code at runtime and is called as CLR</p>\n<p><code class=\"language-text\">What is CLR ❓</code></p>\n<p>So, CLR is essentially an application sitting in memory whose job is to translate IL code to native code</p>\n<p><code class=\"language-text\">How C# is platform independent ❓</code></p>\n<ul>\n<li>C# is platform-independent, i.e. compiled result is always IL code (understandable by CLR).</li>\n<li>CLR is platform-dependent , i.e. specific to a platform in order to translate IL code to native code understable by the machine.</li>\n</ul>\n<h2>Architecture of .Net Apps</h2>\n<p>At high level your .Net app consist of building blocks called Class. These classes collaborate with themselves at runtime and provide some functionality</p>\n<h3>Class Vs Object</h3>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuKhEIImkLd06aTLS2WgwAOabYLmAyV50jdPkQab6Veg69bSjbqDgNWfGEG00\" alt=\"Class\"></p>\n<p>A <code class=\"language-text\">Class</code> is a <code class=\"language-text\">logical</code> <code class=\"language-text\">compile-time</code> <code class=\"language-text\">entity/blueprint</code> which defines</p>\n<ul>\n<li>data/attributes (<code class=\"language-text\">state</code> of instance)</li>\n<li>methods (<code class=\"language-text\">behavior</code> of instance) for an instance/object at runtime. For eg. Think of a car</li>\n</ul>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuKhEIImkLd1EBAhcKb3GpKtCJWNJ-IcfEI16SdvEVX6NGdmyaACDrgIX2MBcvfUb0bcrN0wfUIb0Sm00\" alt=\"Car class\"></p>\n<p>A car has some data/attributes like Make, Model, Color i.e. state of that car and methods like start(), move() i.e. behavior of that car.</p>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuKhEIImkLd0iJScqgEPIKD3DJSnE1TFvAQav84PoVav-4PT2V3oGemtMfg49OkRcbwL2MQN5cSb0PYsNGsfU2j1G0000\" alt=\"Audi8 object\"></p>\n<p>eg. Think of Audi8</p>\n<p>In real world, Car doesn't exist since its a classification of real world object ie. Audi 8 or Mercedes, here Audi 8 is a physical entity.\r\nYou sit in Audi8 or drive an Audi8 i.e. in real world you don't drive a Car, you drive Audi8 which Is a Car (IS-A relationship)</p>\n<p><img src=\"http://www.plantuml.com/plantuml/png/FO-_3W8X38VtFaL7ZU5cOnpkukHZ460WWaqek9oykvLmdVed_NqVh5njgIqdSCaouyEM7T1a-mh_GZuagOuI5J06y3BkJsVfCds2D7qcj-RZLRAxNDJe-cJeE5awArDNojRDuK2nDOvkwEI9UFykon3Y3PziDbZ3syilVW00\" alt=\"Audi8_Is_A_Car\"></p>\n<blockquote>\n<p>Here <code class=\"language-text\">Audi8</code> <strong>IS-A</strong> <code class=\"language-text\">Car</code></p>\n</blockquote>\n<p>In programming, we create audi 8 instance using Car class at runtime. When audi 8 is instantiated, their is some memory allocation (physical)</p>\n<p>An <code class=\"language-text\">object</code> is <code class=\"language-text\">physical</code> <code class=\"language-text\">runtime-time</code> entity which honours IS-A relation with its compile-time entity.</p>\n<blockquote>\n<p>In Real-world applications, we have 10s 100s or even 1000s of classes, each class responsible for a piece of funtionality</p>\n</blockquote>\n<h3>Namespace</h3>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuIf8JCvEJ4zLKF9Bp4qj1l9IbHIgkHGKefrp4ekB5HnZ4Mmd9BOp4jibbgkMoo4rBmLe7W00\" alt=\"Namespace\"></p>\n<p><code class=\"language-text\">How to manage an app with 1000s of classes❓</code></p>\n<p>As the number of classes in our app grows, we need a way to organise these classes, that's where we use <code class=\"language-text\">namespace</code> i.e. container of related classes.</p>\n<p>for eg. in .net app, we have namespaces each of containes multiple classes. We have namepace of working with data, graphics, files, network, etc</p>\n<h3>Assembly</h3>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuIf8JCvEJ4zLK78iBaxDJSgfL5Aevb9GYFPBp4qj1agcAZZ6elATqFZEQ7oNMAvQBeVKl1IWyG00\" alt=\"Namespace\"></p>\n<p><code class=\"language-text\">How to manage an app with 1000s of namespace❓</code></p>\n<p>In Real world apps, contains multiple namespaces, we need a way to organize and maintain these namespaces, that's where we use <code class=\"language-text\">assembly</code> i.e. container of related namespaces, physically its a file under disk which can either be an executable <code class=\"language-text\">EXE</code> or Dynamic Linked Library <code class=\"language-text\">DLL</code></p>\n<p>So when to compile a .Net application, compiler build 1 or more assemblies, depending on how you have partitioned your code</p>\n<p><img src=\"https://www.plantuml.com/plantuml/png/SoWkIImgAStDuIf8JCvEJ4zLK78iACZ9J4uioSpFKrAevb9GY7OiBaxDJSgfL72CHU4weNATKRakiLorN0wfUIb0qm40\" alt=\"Namespace\"></p>\n<h2>Environment Setup</h2>\n<p>Download and install</p>\n<ul>\n<li>SDK - <a href=\"https://dotnet.microsoft.com/en-us/download\">.Net</a></li>\n<li>Code Editor - <a href=\"https://code.visualstudio.com/download\">VS Code</a></li>\n</ul>\n<h2>Hello World App</h2>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">//Program.cs\r\n\r\nusing System;\r\n\r\nnamespace Org.Team.Project\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            Console.WriteLine(&quot;Hello World&quot;);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<h2>Anatomy of .Net App</h2>\n<h3>namespace</h3>\n<p>The <code class=\"language-text\">namespace</code> keyword is used to declare a scope that contains a set of related objects. You can use a namespace to organize code elements and to create globally unique types</p>\n<p>Within a namespace, you can declare zero or more of the following types:</p>\n<ul>\n<li>class</li>\n<li>interface</li>\n<li>struct</li>\n<li>enum</li>\n<li>delegate</li>\n<li>nested namespaces can be declared except in file scoped namespace declarations</li>\n</ul>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">namespace Org.Team.Project\r\n{\r\n    class OrderCode { }\r\n\r\n    interface IOrderCode { }\r\n\r\n    struct Price { }\r\n\r\n    enum PriceMethod { a, b }\r\n\r\n    delegate void OrderCodeEvent(int i);\r\n\r\n    namespace Nested\r\n    {\r\n        class OrderCodeLite { }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>Namespaces implicitly have public access.</p>\n</blockquote>\n<p><code class=\"language-text\">It's possible to define a namespace in two or more declarations ❓</code></p>\n<p>the following example defines two classes as part of the <code class=\"language-text\">Org.Team.Project</code> namespace</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">// MyClass.cs\r\nnamespace Org.Team.Project\r\n{\r\n    class OrderCode\r\n    {\r\n    }\r\n}\r\n\r\n// MyClass1.cs\r\nnamespace Org.Team.Project\r\n{\r\n    class OrderCodeLite\r\n    {\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<p>File scoped namespace declarations enable you to declare that all types in a file are in a single namespace. File scoped namespace declarations are available with C# 10.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  highlight-lines=\"1,13\">\n          <code slot=\"code\">using System;\r\n\r\nnamespace SampleFileScopedNamespace;\r\n\r\nclass SampleClass { }\r\n\r\ninterface ISampleInterface { }\r\n\r\nstruct SampleStruct { }\r\n\r\nenum SampleEnum { a, b }\r\n\r\ndelegate void SampleDelegate(int i);\r\n\r\nnamespace AnotherNamespace; // Not allowed!\r\n\r\nnamespace ANestedNamespace // Not allowed!\r\n{\r\n   // declarations...\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>File scoped namespaces can't include additional namespace declarations.\r\nYou cannot declare a nested namespace or a second file-scoped namespace</p>\n</blockquote>\n<p>The compiler adds a default namespace. This unnamed namespace, sometimes referred to as the global namespace, is present in every file. It contains declarations not included in a declared namespace. Any identifier in the global namespace is available for use in a named namespace.</p>\n<h3>using directive</h3>\n<p>The <code class=\"language-text\">using</code> directive allows you to use types defined in a namespace without specifying the fully qualified namespace of that type.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  highlight-lines=\"3 11\">\n          <code slot=\"code\">//Program.cs\r\n\r\nusing System;\r\n\r\nnamespace Org.Team.Project\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            Console.WriteLine(&quot;Hello World&quot;);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>At the beginning of a source code file, before any namespace or type declarations.</p>\n</blockquote>\n<p>You can also create an alias for a namespace or a type with a using <code class=\"language-text\">alias</code> directive.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  highlight-lines=\"3 11\">\n          <code slot=\"code\">//Program.cs\r\n\r\nusing sys = System;\r\n\r\nnamespace Org.Team.Project\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main()\r\n        {\r\n            sys.Console.WriteLine(&quot;Hello World&quot;);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<p>You can apply two modifiers to a using directive:</p>\n<ul>\n<li>The <code class=\"language-text\">static</code> modifier imports the static members and nested types from a single type rather than importing all the types in a namespace.</li>\n<li>The <code class=\"language-text\">global</code> modifier has the same effect as adding the same using directive to every source file in your project. This modifier was introduced in C# 10.</li>\n</ul>\n<h4>global modifier</h4>\n<p>Adding the <code class=\"language-text\">global</code> modifier to a <code class=\"language-text\">using directive</code> means that using is applied to all files in the compilation (typically a project). The global using directive was added in C# 10.</p>\n<p>syntax</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">global using &lt;FQNS&gt;;\r\n\r\n// FQNS is the fully qualified name of the namespace whose types can be referenced without specifying the namespace</code>\n        </deckgo-highlight-code>\n<p>A global using directive can appear at the beginning of any source code file. All global using directives in a single file must appear before:</p>\n<ul>\n<li>All using directives without the global modifier.</li>\n<li>All namespace and type declarations in the file.</li>\n</ul>\n<p>You may add global using directives to any source file. Typically, you'll want to keep them in a single location. The order of global using directives doesn't matter, either in a single file, or between files.</p>\n<p>Usage\r\nat code level, in single as GlobalUsings.cs at project root level with concise list of frequently used namespaces.</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">// vendor, 3th party namespaces\r\nglobal using System.IO;\r\nglobal using Microsoft.AspNetCore.Builder;\r\nglobal using Microsoft.AspNetCore.Hosting;\r\nglobal using Microsoft.Extensions.DependencyInjection;\r\nglobal using Microsoft.Extensions.Hosting;\r\n\r\n// your project namesapces \r\nglobal using Org.Team.Project.App;\r\nglobal using Org.Team.Project.Infra.Data;\r\nglobal using Org.Team.Project.Infra.Data.Contexts;\r\nglobal using Org.Team.Project.Infra.Shared;</code>\n        </deckgo-highlight-code>\n<p>You can also globally include a namespace by adding a <Using> item to your project file, for example, <Using Include=\"My.Awesome.Namespace\" /></p>\n<deckgo-highlight-code language=\"xml\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;ItemGroup&gt;\r\n  &lt;Using Include=&quot;My.Awesome.Namespace&quot; Alias=&quot;Awesome&quot;/&gt;\r\n&lt;/ItemGroup&gt;</code>\n        </deckgo-highlight-code>\n<h4>static modifier</h4>\n<p>The using static directive names a type whose static members and nested types you can access without specifying a type name\r\nsyntax</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  >\n          <code slot=\"code\">using static &lt;FQTN&gt;;\r\n\r\n// FQTN is the name of the type whose static members and nested types can be referenced without specifying a type name</code>\n        </deckgo-highlight-code>\n<p>You can access static members of a type without having to qualify the access with the type name</p>\n<deckgo-highlight-code language=\"csharp\" terminal=\"carbon\" theme=\"dracula\" line-numbers=\"true\"  highlight-lines=\"1,2 7,8\">\n          <code slot=\"code\">using static System.Console;\r\nusing static System.Math;\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        WriteLine(\r\n            Sqrt(3*3 + 4*4)\r\n        );\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<div id=\"markmap-13\" class=\"gatsby-markmap\"><script type=\"text/markmap\">{\"data\":{\"type\":\"heading\",\"depth\":0,\"payload\":{\"lines\":[0,1]},\"content\":\"Raodmap\",\"children\":[{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[2,3]},\"content\":\"Fundamentals\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[6,7]},\"content\":\"Item 1\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[8,9]},\"content\":\"Item 2\"}]},{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[10,11]},\"content\":\"Beginner\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[14,15]},\"content\":\"Item 1\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[16,17]},\"content\":\"Item 2\"}]},{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[18,19]},\"content\":\"Intermediate\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[22,23]},\"content\":\"Item 1\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[24,25]},\"content\":\"Item 2\"}]},{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[26,27]},\"content\":\"Advance\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[30,31]},\"content\":\"Item 1\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[32,33]},\"content\":\"Item 2\"}]},{\"type\":\"heading\",\"depth\":1,\"payload\":{\"lines\":[34,35]},\"content\":\"Expert\",\"children\":[{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[38,39]},\"content\":\"Item 1\"},{\"type\":\"heading\",\"depth\":2,\"payload\":{\"lines\":[40,41]},\"content\":\"Item 2\"}]}]}}</script></div>","frontmatter":{"slug":"dotnet","stack":".Net","title":"Intro","next":"dotnet/fundamentals/engine","prev":""},"id":"482a45bc-ab48-5dbe-8a09-c4645a833999","tableOfContents":"<ul>\n<li>\n<p><a href=\"#net-framework-vs-net-standard-vs-net\">.Net Framework Vs .Net Standard Vs .Net</a></p>\n</li>\n<li>\n<p><a href=\"#c-vs-net\">C# vs .Net</a></p>\n</li>\n<li>\n<p><a href=\"#architecture-of-net-framework\">Architecture of .Net Framework</a></p>\n</li>\n<li>\n<p><a href=\"#clr-common-language-runtime\">CLR (Common Language Runtime)</a></p>\n</li>\n<li>\n<p><a href=\"#architecture-of-net-apps\">Architecture of .Net Apps</a></p>\n<ul>\n<li><a href=\"#class-vs-object\">Class Vs Object</a></li>\n<li><a href=\"#namespace\">Namespace</a></li>\n<li><a href=\"#assembly\">Assembly</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#environment-setup\">Environment Setup</a></p>\n</li>\n<li>\n<p><a href=\"#hello-world-app\">Hello World App</a></p>\n</li>\n<li>\n<p><a href=\"#anatomy-of-net-app\">Anatomy of .Net App</a></p>\n<ul>\n<li>\n<p><a href=\"#namespace-1\">namespace</a></p>\n</li>\n<li>\n<p><a href=\"#using-directive\">using directive</a></p>\n<ul>\n<li><a href=\"#global-modifier\">global modifier</a></li>\n<li><a href=\"#static-modifier\">static modifier</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","timeToRead":7},"allDirectory":{"edges":[{"node":{"id":"e32d3e74-5780-58fd-901a-b9598fefade9","name":"advance","relativeDirectory":"dotnet"}},{"node":{"id":"558bfc97-9681-57cc-87f7-8571e93aa10f","name":"beginner","relativeDirectory":"dotnet"}},{"node":{"id":"96cd54ee-4054-55f5-ba7e-3668ce81a864","name":"expert","relativeDirectory":"dotnet"}},{"node":{"id":"401abbcd-8d07-5458-8c3e-c0491bca8cb1","name":"fundamentals","relativeDirectory":"dotnet"}},{"node":{"id":"074eff6a-e957-510d-9b54-65d4d61df170","name":"intermediate","relativeDirectory":"dotnet"}}]}},"pageContext":{"slug":"dotnet","breadcrumb":{"location":"/books/dotnet/","crumbs":[{"pathname":"/","crumbLabel":"Root"},{"pathname":"/books/","crumbLabel":"books"},{"pathname":"/books/dotnet/","crumbLabel":"dotnet"}]}}},"staticQueryHashes":["2948616848"],"slicesMap":{}}